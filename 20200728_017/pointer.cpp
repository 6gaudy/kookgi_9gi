#include "config.h"

void main() {

	int a = 100;		// 일반 변수 => 데이터(상수)를 기억한다.

//	포인터란 변수나 배열이 메모리에 생성된 주소를 말한다. => 포인터를 기억하는 변수를 포인터 변수라 부른다.
//	포인터 변수는 선언할 때 컴파일러에게 포인터 변수임을 알려주기 위해 변수의 이름 앞에 "*"를 붙여서 선언한다.
//	int* p;				// 포인터 변수 => 포인터 변수를 선언만 했으므로 포인터 변수에는 쓰레기가 들어있다.

//	포인터 선언시 붙이는 자료형은 포인터 변수에 주소를 저장할 변수나 배열의 자료형을 적어주면 되고 포인터 변수 선언시 붙여주는 자료형의
//	크기와 관계없이 포인터 변수는 무조건 4byte의 크기를 가진다.
//	printf("포인터 변수의 크기 : %d\n", sizeof(p));
//	int* p = NULL;		// 포인터 변수를 선언하고 NULL이나 0을 초기치로 지정하면 빈 포인터 변수를 선언할 수 있다.

//	포인터 변수는 데이터(상수)를 기억하지 않고 포인터(주소)를 기억하는 변수를 말한다. => 데이터를 넣으면 에러가 발생된다.
//	int* p = 100;		// 데이터(상수)를 넣으려 했으므로 에러가 발생된다.
//	int* p = a;			// 변수 a에 저장된 데이터(상수)를 넣으려 했으므로 에러가 발생된다.

//	포인터 변수는 일반 변수와 같이 포인터 변수 선언시 초기화 시킬 수 있고 선언만 해 두고 나중에 초기화 시켜서 사용할 수 있다.
//	int* p = &a;		// 포인터 변수에 일반 변수 a가 메모리에 생성된 주소를 저장한다. => 포인터 변수 선언 시 초기화
	int* p;
	p = &a;				// 포인터 변수에 일반 변수 a가 메모리에 생성된 주소를 저장한다. => 포인터 변수 선언 후 나중에 초기화

//	printf("포인터 변수에 저장된 내용 : %d\n", p);
//	printf("포인터 변수에 저장된 내용 : %08x\n", p);
//	cout << "포인터 변수에 저장된 내용 : " << p << endl;
//	printf("======================================================\n");

//	"&"는 이항 연산자로 사용되면 비트간의 and 연산을 하는 비트 연산자로 사용되고 단항 연산자로 사용되면 기억장소가 메모리에 생성된 주소를
//	얻어오는 번지 연산자로 사용된다.

//	비트 연산자 : &(and), |(or), ~(not, 0 => 1, 1 => 0, 1의 보수), ^(xor, 배타적 논리합, 두 개의 비트가 다르면 1)
	cout << "6 & 5 = " << (6 & 5) << endl;	// 4
	cout << "6 | 5 = " << (6 | 5) << endl;	// 7
	cout << "6 ^ 5 = " << (6 ^ 5) << endl;	// 3
	cout << "~6 = " << ~6 << endl;			// -7 

//	6 : 0000 0110		6 : 0000 0110		6 : 0000 0110		6 : 0000 0110
//	5 : 0000 0101		5 : 0000 0101		5 : 0000 0101		~ : 1111 1001 => 최상위 bit가 1이므로 음수이다.
//	& : 0000 0100(4)	| : 0000 0111(7)	^ : 0000 0011(3)	2의 보수로 재보수를 취한다. => 0000 0111 => 7 => -7
	printf("======================================================\n");

	cout << "변수 a에 저장된 내용 : " << a << endl;
	cout << "변수 a가 메모리에 생성된 주소 : " << &a << endl;
	cout << "포인터 변수 p에 저장된 내용 : " << p << endl;

//	"*"이 이항 연산자로 사용되면 곱셈을 의미하지만 단항 연산자로 사용되면 포인터 변수에 저장된 주소로 접근해 그 주소에 저장된 내용을
//	얻어오는(참조하는) 참조 연산자로 사용된다.
	cout << "포인터 변수 p가 참조하는 내용 : " << *p << endl;
	printf("======================================================\n");

//	참조(reference) 변수 => c++에서 추가
//	참조 변수는 포인터 변수와 똑같이 변수나 배열이 메모리에 생성된 주소를 기억한다.
//	참조 변수를 선언할 때 컴파일러에게 참조 변수임을 알려주기 위해서 변수 이름 앞에 "&"를 붙여서 선언한다.
//	포인터 변수에 주소를 넣어줄 때 선언과 동시에 넣어주는 경우와 선언 후 나중에 넣어주는 경우를 모두 사용할 수 있지만 참조 변수는 반드시
//	선언과 동시에 초기화 시켜야 한다.
//	포인터 변수에 주소를 넣어줄 때는 변수 이름 앞에 번지 연산자 "&"를 붙여야 했지만 참조 변수에 주소를 넣어줄 때는 그냥 변수 이름만 적으면
//	c++ 컴파일러가 알아서 그 변수가 메모리에 생성된 주소를 얻어와 넣어준다.

	int b = 200;
//	int& r;				// 참조 변수 선언시 초기화를 시키지 않아서 에러가 발생된다.
//	int& r = 200;		// 에러
//	int& r = &b;		// 에러
	int& r = b;			// 참조 변수 r에 변수 b가 생성된 주소가 저장된다.

	cout << "변수 b에 저장된 내용 : " << b << endl;
	cout << "변수 b가 메모리에 생성된 주소 : " << &b << endl;

//	참조 변수에 저장된 주소를 사용해야 한다면 참조 변수 앞에 "&"를 붙여야 한다.
	cout << "참조 변수 r에 저장된 내용 : " << &r << endl;

//	포인터 변수는 포인터 변수가 참조하는 데이터를 얻어오려면 참조 연산자를 사용해야 하지만 참조 변수는 참조 변수가 참조하는 데이터를 얻어오려
//	하는 경우 참조 변수의 이름만 사용하면 된다.
	cout << "참조 변수 r이 참조하는 내용 : " << r << endl;

}