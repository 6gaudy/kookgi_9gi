#include "config.h"

//	함수 작성 방법
//	리턴타입(함수의 자료형) 함수이름([자료형 인수, ...]) {		// 함수의 머리 => 함수의 원형(프로토타입)을 선언할 때 사용한다.
//		함수가 실행할 문장;
//		...;
//		[return 값;]		// 함수의 실행 결과의 데이터 타입, 실행 결과가 없으면 생략 가능하고 이 때 리턴 타입은 void 라고 쓴다.
//	}

//	함수가 실행(호출)된 후 "}"를 만나거나 return을 만나면 함수가 종료되고 함수를 호출한 곳으로 돌아간다.
//	돌아갈 때 return 값이 있으면 return 값을 가지고 돌아간다. => return 값은 없거나 딱 1개만 가능하다.
//	함수의 리턴 타입에는 함수를 실행한 후 반환되는 결과(return 값)의 자료형을 적는다.
//	return이 없는 함수는 return 되는 데이터 타입이 없으므로 리턴 타입에 void 라고 적는다.

int total() {
	int sum = 0;
	for (int i = 1; i <= 100; i++) {
		sum += i;
	}
	return sum;
}

//	함수 오버로딩
//	함수 오버로딩은 하나의 파일 또는 클래스에서 같은 이름을 가지는 함수를 여러개 만들어 사용할 수 있는 것을 말한다.
//	컴파일러는 함수의 이름이 같을 경우 인수의 개수로 함수를 식별하고 인수의 개수도 같으면 인수의 데이터 타입으로 함수를 식별한다.

int total(int n) {
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		sum += i;
	}

//	가인수 값을 변경한다.
	n = 999;
	printf("가인수 n : %d\n", n);

	return sum;
}

//	매개 변수 전달 방법(call by value) => 값에 의한 호출
//	함수를 호출하는 쪽의 인수(실인수)의 값을 복사해서 호출당하는 함수 쪽의 인수(가인수)에 넣어준다.
//	실인수와 가인수는 각각 독립된 기억공간을 가진다. => 함수에서 가인수의 값이 변경되더라도 실인수 값은 변경되지 않는다.
//	=> 부작용(side effect) 현상이 발생되지 않는다.
//	실인수와 가인수의 이름은 같던 다르던 아무 상관없지만 데이터 타입은 반드시 같아야하고 함수를 호출할 때 가인수로 여러개의 값을 넘겨줄 수
//	있지만 함수가 실행된 결과(return 값)은 딱 1개만 되돌려줄 수 있다.

int total(int x, int y) {
	int sum = 0;
	for (int i = x; i <= y; i++) {
		sum += i;
	}
	return sum;
}

void main() {

	printf("1 ~ 100의 합계 : %d\n", total());
	printf("1 ~ 100의 합계 : %d\n", total());

	int n;
	cout << "n : ";
	cin >> n;
	cout << "1 ~ " << n << "의 합계 : " << total(n) << endl;
	printf("실인수 n : %d\n", n);

	int x, y;
	cout << "x, y : ";
	cin >> x >> y;
	cout << x << " ~ " << y << "의 합계 : " << total(x, y) << endl;

}